# -*- coding: utf-8 -*-
"""Entrenamiento_y_validacion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10BJP2z0rKQ9dtkSj7eU-dpAGncsqAzzn
"""
#Bryan Castro Lugo
#Gildardo Hernandez Palma
#Import the libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import os
from sklearn.neural_network import MLPClassifier
from sklearn.metrics import classification_report
from sklearn.ensemble import RandomForestClassifier
import cv2
from skimage import io

#Training
## Load the training dataset
training = np.load('../data/training/M_train_placa.npy')
DBtraining= pd.read_csv('../data/training/placas_train.csv')
plt.imshow(training[0],"gray")  # A random image is graphed to check
plt.show()
print("Para entrenamiento hay {} placas".format(str(len(training)))) #shows the amount of data that the database has for training 
DBtraining.head(1)

#Testing
## Load the testing dataset
testing = np.load('../data/testing/M_test_placa.npy')
DBtesting = pd.read_csv('../data/testing/placas_test.csv')
plt.imshow(testing[0],"gray") # A random image is graphed to check
plt.show()
print("Para entrenamiento hay {} placas".format(str(len(testing))))  #shows the amount of data that the database has for testing
DBtesting.head(1)

#Binarizando la imágen  
testing = testing/255
training = training/255
#Ajuste para que todas las letras tengan el mismo tamaño
def separa_letras(P_gris):   # separacion de letras
  L0 = P_gris[30:125,15:75]
  L1 = P_gris[30:125,75:135]
  L2 = P_gris[30:125,135:200]
  L3 = P_gris[30:125,200:260]
  L4 = P_gris[30:125,265:325]
  L5 = P_gris[30:125,330:390]
  return L0,L1,L2,L3,L4,L5

#Acondicionamos los vectores de entrada para la el randomforest

#Imágen
def acond_img(letras_matriz):
    Xtl1 = []
    Xtl2 = []
    Xtl3 = []
    Xtl4 = []
    Xtl5 = []
    Xtl6 = []
    #separa los x_test y x_train para el entrenamiento del sistema
    for i in range(len(letras_matriz)):
        l1,l2,l3,l4,l5,l6 = separa_letras(letras_matriz[i])
        Xtl1.append(np.reshape(l1,(5700)))
        Xtl2.append(np.reshape(l2,(5700))) 
        Xtl3.append(np.reshape(l3,(6175))) 
        Xtl4.append(np.reshape(l4,(5700))) 
        Xtl5.append(np.reshape(l5,(5700)))
        Xtl6.append(np.reshape(l6,(5700))) 

    Xtl1 = np.array(Xtl1)
    Xtl2 = np.array(Xtl2)
    Xtl3 = np.array(Xtl3)
    Xtl4 = np.array(Xtl4)
    Xtl5 = np.array(Xtl5)
    Xtl6 = np.array(Xtl6)
    return Xtl1,Xtl2,Xtl3,Xtl4,Xtl5,Xtl6

#separa los y_test y y_train para el entrenamiento del sistema
def acond_target(DB):
    Ytl1 = np.zeros([DB.shape[0],1])
    Ytl2 = np.zeros([DB.shape[0],1])
    Ytl3 = np.zeros([DB.shape[0],1])
    Ytl4 = np.zeros([DB.shape[0],1])
    Ytl5 = np.zeros([DB.shape[0],1])
    Ytl6 = np.zeros([DB.shape[0],1])
    for i in range(DB.shape[0]): 
        Ytl1[i]= DB.L1.values[i]
        Ytl2[i]= DB.L2.values[i]
        Ytl3[i]= DB.L3.values[i]
        Ytl4[i]= DB.N1.values[i]
        Ytl5[i]= DB.N2.values[i]
        Ytl6[i]= DB.N3.values[i]
    return Ytl1,Ytl2,Ytl3,Ytl4,Ytl5,Ytl6

#Imagen como vector(X)
Numero = ["0","1","2","3","4","5","6","7","8","9"]#Su equivalente numérico A=0, B=1...Z=25

#Datos training
Xtrl1,Xtrl2,Xtrl3,Xtrn1,Xtrn2,Xtrn3 = acond_img(training)

#Datos testing
Xtel1,Xtel2,Xtel3,Xten1,Xten2,Xten3 = acond_img(testing)


#Acondicionando prediccionesm(Y) "target"
letra = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']#Su equivalente numérico A=0, B=1...Z=25

#Datos training
Ytrl1,Ytrl2,Ytrl3,Ytrn1,Ytrn2,Ytrn3 = acond_target(DBtraining)

#Datos testing
Ytel1,Ytel2,Ytel3,Yten1,Yten2,Yten3 = acond_target(DBtesting)

Xtel3.shape

"""# Metodo de clasificacion por RandomForest"""

#Entrenamiento y validación para la letra 1
#Declaracion del clasificador 
Cgen = RandomForestClassifier(n_estimators=100, bootstrap = True, verbose=2, max_features = 'sqrt')
l1 = Cgen.fit(Xtrl1,Ytrl1); # Entrenamiento del clasificador
# Predicciones de clases reales
predl1 =  l1.predict(Xtel1)
print(classification_report(Ytel1,predl1,target_names = letra)) # muestra los resultados del clasificador, muestra precision, f-score

#Entrenamiento y validación para la letra 2
l2 = Cgen.fit(Xtrl2,Ytrl2) # entrenamiento
predl2 = l2.predict(Xtel2)  #Prediccion
print(classification_report(Ytel2,predl2,target_names = letra)) # muestra los resultados del clasificador, muestra precision, f-score

#Entrenamiento y validación para la letra 3
l3 = Cgen.fit(Xtrl3,Ytrl3) #entrenamiento
predl3 = l3.predict(Xtel3) # Prediccion
print(classification_report(Ytel3,predl3,target_names = letra)) # muestra los resultados del clasificador, muestra precision, f-score

#Entrenamiento y validación para numero 1
n1 = Cgen.fit(Xtrn1,Ytrn1) # entrenamiento
predn1 = n1.predict(Xten1) #prediccion
print(classification_report(Yten1,predn1,target_names = Numero)) # muestra los resultados del clasificador, muestra precision, f-score

#Entrenamiento y validación para numero 2
n2 = Cgen.fit(Xtrn2,Ytrn2) #entrenamiento
predn2 = n2.predict(Xten2) # prediccion
print(classification_report(Yten2,predn2,target_names = Numero)) # muestra los resultados del clasificador, muestra precision, f-score

#Entrenamiento y validación para numero 3
n3 = Cgen.fit(Xtrn3,Ytrn3) #entrenamiento 
predn3 = n3.predict(Xten3) #prediccion
print(classification_report(Yten3,predn3,target_names = Numero)) # muestra los resultados del clasificador, muestra precision, f-score

"""# Test gráfico
En este apartado probamos el clasificador llamando algunas placas de la base  de datos y miramos si el resultado es acertado con base al f1-score

"""

#Definimos una función que junte los clasificadores y haga la lectura de la placa perteneciente a la base de datos para testing
def test_read(T_I):
    image = io.imread('../data/testing/imagen_testing/'+str(T_I)+'.jpg')  
    #image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)#convertir color 
    plt.imshow(image)
    plt.title("Lectura: "+
    letra[int(predl1[T_I])]+
    letra[int(predl2[T_I])]+
    letra[int(predl3[T_I])]+" "+
    str(int(predn1[T_I]))+
    str(int(predn2[T_I]))+
    str(int(predn3[T_I])))
    plt.show()
    ## incorpora los resultados de los clasificadores 


#Test gráfico
test_read(0)

test_read(50)

test_read(100)

test_read(200)

test_read(299)